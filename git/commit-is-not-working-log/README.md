コミットは作業ログではない！

いきなりだけど、こんなコミット、よく見ない？

![bad commits.png](https://qiita-image-store.s3.amazonaws.com/0/113398/5c598c48-daec-3f6f-a143-04c0e5decc9d.png)
（例１とする）

見た瞬間に腕まくりして修正依頼と理由を書き出したくなっちゃう感じ！

これが良くない理由を、持論だけど挙げてみるよ

## このコミットについて
### :x: コミットは作業単位でするものではない
プルリクエスト（以下 PR）をレビューする側に立って考えるとよくわかるのだけど、
PRレビューをする人が欲しているのは(= masterブランチが欲している、チームが欲していると言っても良い）作業者の作業ログではない。

レビューする人にとって、そのPR作成者が「どれくらいの時間をかけた」とか「休日もコミットを重ねてた」とか
「何ファイルも直さなくちゃあならなくて大変だった」とか「いつどこでブランチを切り換えて自分の出したPRを見てくれていた」とか、
そんなことは**ぶっちゃけ全く興味がない**んだ。

欲しいのは「生成物と成果」であって、それを「どの様な作業工程」で作ったかはどーでも良い。

### :white_check_mark: コミットは実現した事単位で行う
価値のあるコミットと言うのは、何かを実現できる様になる最低単位、もしくはその一部なんじゃあないか、と思っている。

仕様を実現するなり、リファクタリングをするなり、何かしらの要求に基づいてコードの改修をしているはずなので、
その問題を解決する単位がコミットなんじゃあないか、と思っている。

冒頭のPRのコミット群は、せめてこうなっていて欲しい。

![normal-commits.png](https://qiita-image-store.s3.amazonaws.com/0/113398/71d5a0ff-7f74-1e25-51d1-faf14d226f16.png)
（例２とする）

### :x: レビューしづらい
2つのスクショを見比べてみると、どちらがPRを(= コミットを）理解しやすいかは明白だ。

前者のコミットだと、「まず最終的に、こいつはこのPR内で何をやったの？」ということが不明瞭だ。
目で関係ないコミットをはじきながら、要求実現に関係しそうなコミットメッセージだけを探さないとならない。

### :x: マージされたコミットはリポジトリがある限り、永劫に残る
正直なところ、この様なコミットは「かなり恥ずかしい行為」だと思っている。
マージされてしまったら、よほどのことが無い限りは残り続け、コミッターもマージした人も恥をさらし続けることになる。

まぁそれは許容してしまうのだとしても、実害という観点から見てもやはりマージされて欲しくないコミットだ。

例えばreleaseブランチをmasterに取り込むときとか、過去のコミットを一覧で見るという事がある。
その時にやはり意味の無いコミットが混じっていると見通しが悪いものだ。

まぁそれも許容してしまうのだとしても、最初のPRの問題の本質は「コミットに意味が無い」ことなので、
マージして残すという事は断固としてあってはならない。

## 少し発展して、差分について
コミットメッセージだけを見ると、良くなった。

次はもう一歩進んで、差分について考えてみようと思う。

実はこのPRは、「本質であるタイプ判定」に加え「クラス名変更」と「パッケージの変更」も行っている。

PRの差分を見てみよう。

### :x: コミットメッセージとやったことが一致していない
例２のPRの差分は、こんな感じになっている。
![bad-diff.png](https://qiita-image-store.s3.amazonaws.com/0/113398/84735bfa-532d-b0a3-a421-8e5ca63ef7f1.png)

全部削除して、全部新規作成になってしまっているが、そんなはずはないだろう。

これは小さいコミットだから、と「タイプ変更」以外もやってしまうパターンで、良くあるパターンだと思う。
そして、ついでにやってしまうことの内、最も罪深いのが「クラス名変更」もしくは「クラス移動」だ。

何度もPRを出したり、見たりしているとわかるはずなんだけど、それを行ってしまうと差分がこんな風になってしまう。

こんなPRは、見るときに
「え〜と、クラス名はＸ→Ｏで、パッケージが〜〜で、あ、で、タイプ変更ってこれね？」
ってなってしまい、見る方はすごい辛いしレビューの質も落ちる。

これは「1つのコミットで1つを実現する（解決する）」を満たせていないと、すぐ発生する。

そしてまたタチの悪いのは、PR出した側はあまり自分のPRをみないので、なかなか気付かないことだ。
見つけたらちゃんと指摘をしよう。

### :white_check_mark: 1つのコミットで1つを行う
次に、最終的な差分は全く同じだが、コミットの仕方を変えた（例３）を見てみたい。

![good-commits.png](https://qiita-image-store.s3.amazonaws.com/0/113398/a8eff781-96d5-fa77-8d54-bc0ad1d1d9bf.png)

これは「パッケージ変更」と「クラス名変更」と「タイプ判定」を全て別にコミットしている。

PRの差分は当然同じで全削除、全新規なのだが、このPRはコミット単位でレビューすることが出来る。

![good-diff-1.png](https://qiita-image-store.s3.amazonaws.com/0/113398/1e7b64a4-d7c9-9399-1e30-f25614e96920.png)
![good-diff-2.png](https://qiita-image-store.s3.amazonaws.com/0/113398/e51f4c2b-3bcb-519e-8873-63f9fb121e2d.png)
![good-diff-3.png](https://qiita-image-store.s3.amazonaws.com/0/113398/febeb638-f718-6c36-c369-f2fc242efc94.png)

どちらのレビューがしやすいか、バグを見つけやすいかは一目瞭然だ。

## 実際には
今回はあくまで例であるけど、本質は実業務でもかわらないと思う。

すこし難しくなるのは、パッケージ変更等を別コミットにするのは当然として、「別PRにするか」だ。
これはもうチーム内での調整とか、さじ加減としか言いようが無い。

例えば「その本質の部分の改修、待ってるから早くマージして欲しい」とか言われたら、あえて同じPRで移動まで済ます必要はない。

他には例えば、他の人のPRを見ていて「あ、このファイル俺これから移動しようとしてたけど、移動と改修 vs 改修はコンフリクトが超辛いやつだ」って
気づけたら、別PRで移動するか、直接話してマージが後の方がそれをするか、とか調整すれば良い。

この辺はどちらかと言うと、**PRを出すよりPRを見る事によって得られる経験**で出来る様になることだ。

### :x: おまけ 悪いコミット単位の実例っぽい例
新しい参照APIを作る　というPRだったとする

ﾋﾟｷ って来る感じねｗ
![rel-bad-commits.png](https://qiita-image-store.s3.amazonaws.com/0/113398/aaf7cddc-a11f-b331-1bc9-44bc77c87b03.png)

「コミットメッセージはお前のツイッターじゃあねーから（怒）」
「お前、これで俺に何をレビューしろ、と？（怒）」

ってなるやつねｗ

これだけ大きいとPR全体差分では絶対にレビューの質が落ちるので、大きい改修の時こそ、コミット単位でレビューが出来る様になっているのが理想だ。
コミットをするときに、自分のPRが最終的にどんな感じになるのか、考えながらコミットすると良い。

### :white_check_mark: おまけ 良いコミット単位の実例っぽい例
> 価値のあるコミットと言うのは、何かを実現できる様になる最低単位、もしくはその一部

もしくはその一部と言うのは、〜〜を実現するにはAしてBしてCしないといけません、のA, B, C ひとつずつのこと

先述の通り、PRは何かを実現するために出されるので、コミットはその必要事項の列挙みたいになるはず。

例えばこう
![rel-good-commits.png](https://qiita-image-store.s3.amazonaws.com/0/113398/d70fc6f7-5f5f-1154-3199-e0ff254216b2.png)
新しい参照APIを作るには、以下が必要です。
それぞれの改修については、各コミットを参照してください。

ってな感じだ。

レビューしやすそうだね？

## 具体的な操作
これらを発生させない方法をいくつか挙げてみる。

ここからはもう個人のスタイルなので、軽く、キーワードを載せる程度に。
知らなかったらggって欲しい。

すぐ思いつくのは3つ

### stash
見ていると案外多いのが「ブランチを切り換えるためにコミット」ってパターン。

そんなんは`git stash`でも使え。

### commit amend
直前のコミットに改修を足し込むことができる。

僕は一息付いたりする時は、とりあえず出来たつもりでちゃんとしたコミットメッセージを書いて、
残りは`amend`でくっつけちゃうってパターンが多い。

ブランチ切り替えにも使えなくもない。

先にコミットだけ作っておいて、そこにポイポイと改修を放り込んでいくイメージ、かな？

### rebase -i
これは複数のコミットをまとめることが出来る。

ローカルマシンでは「作業中」「作業中」「作業中」「タイプ判定」みたいにコミットしていても、
PRを出す前に`rebase -i`して1つのコミットにまとめてくれれば全く文句ない。

けど、僕は面倒だからこれは全くやらない。

ちょっと気をつけていれば、そもそも最初から綺麗にコミット出来るし、なんかあっても大抵はすぐ気付くので`amend`で十分だから。


まぁGitなんて案外なんでもどうにかなるんで、イケてないコミットをしない様に気をつけつつ、してしまったら何とかして直そう。
それも訓練になるはずだ。


それでは、ばいばい ﾉｼ
